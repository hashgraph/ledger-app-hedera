"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.message
import proto.basic_types_pb2
import proto.duration_pb2
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class CryptoCreateTransactionBody(google.protobuf.message.Message):
    """
    Create a new account. After the account is created, the AccountID for it is
    in the receipt. It can also be retrieved with a GetByKey query. Threshold
    values can be defined, and records are generated and stored for 25 hours for
    any transfer that exceeds the thresholds. This account is charged for each
    record generated, so the thresholds are useful for limiting record
    generation to happen only for large transactions.

    The Key field is the key used to sign transactions for this account. If the
    account has receiverSigRequired set to true, then all cryptocurrency
    transfers must be signed by this account's key, both for transfers in and
    out. If it is false, then only transfers out have to be signed by it. When
    the account is created, the payer account is charged enough hbars so that
    the new account will not expire for the next autoRenewPeriod seconds. When
    it reaches the expiration time, the new account will then be automatically
    charged to renew for another autoRenewPeriod seconds. If it does not have
    enough hbars to renew for that long, then the remaining hbars are used to
    extend its expiration as long as possible. If it is has a zero balance when
    it expires, then it is deleted. This transaction must be signed by the payer
    account. If receiverSigRequired is false, then the transaction does not have
    to be signed by the keys in the keys field. If it is true, then it must be
    signed by them, in addition to the keys of the payer account.

    An entity (account, file, or smart contract instance) must be created in a
    particular realm. If the realmID is left null, then a new realm will be
    created with the given admin key. If a new realm has a null adminKey, then
    anyone can create/modify/delete entities in that realm. But if an admin key
    is given, then any transaction to create/modify/delete an entity in that
    realm must be signed by that key, though anyone can still call functions on
    smart contract instances that exist in that realm. A realm ceases to exist
    when everything within it has expired and no longer exists.

    The current API ignores shardID, realmID, and newRealmAdminKey, and creates
    everything in shard 0 and realm 0, with a null key. Future versions of the
    API will support multiple realms and multiple shards.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    INITIALBALANCE_FIELD_NUMBER: builtins.int
    PROXYACCOUNTID_FIELD_NUMBER: builtins.int
    SENDRECORDTHRESHOLD_FIELD_NUMBER: builtins.int
    RECEIVERECORDTHRESHOLD_FIELD_NUMBER: builtins.int
    RECEIVERSIGREQUIRED_FIELD_NUMBER: builtins.int
    AUTORENEWPERIOD_FIELD_NUMBER: builtins.int
    SHARDID_FIELD_NUMBER: builtins.int
    REALMID_FIELD_NUMBER: builtins.int
    NEWREALMADMINKEY_FIELD_NUMBER: builtins.int
    MEMO_FIELD_NUMBER: builtins.int
    MAX_AUTOMATIC_TOKEN_ASSOCIATIONS_FIELD_NUMBER: builtins.int
    STAKED_ACCOUNT_ID_FIELD_NUMBER: builtins.int
    STAKED_NODE_ID_FIELD_NUMBER: builtins.int
    DECLINE_REWARD_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> proto.basic_types_pb2.Key:
        """*
        The key that must sign each transfer out of the account. If
        receiverSigRequired is true, then it must also sign any transfer into the
        account.
        """
    initialBalance: builtins.int
    """*
    The initial number of tinybars to put into the account
    """
    @property
    def proxyAccountID(self) -> proto.basic_types_pb2.AccountID:
        """*
        [Deprecated] ID of the account to which this account is proxy staked. If
        proxyAccountID is null, or is an invalid account, or is an account that
        isn't a node, then this account is automatically proxy staked to a node
        chosen by the network, but without earning payments. If the proxyAccountID
        account refuses to accept proxy staking , or if it is not currently
        running a node, then it will behave as if proxyAccountID was null.
        """
    sendRecordThreshold: builtins.int
    """*
    [Deprecated]. The threshold amount (in tinybars) for which an account
    record is created for any send/withdraw transaction
    """
    receiveRecordThreshold: builtins.int
    """*
    [Deprecated]. The threshold amount (in tinybars) for which an account
    record is created for any receive/deposit transaction
    """
    receiverSigRequired: builtins.bool
    """*
    If true, this account's key must sign any transaction depositing into this
    account (in addition to all withdrawals)
    """
    @property
    def autoRenewPeriod(self) -> proto.duration_pb2.Duration:
        """*
        The account is charged to extend its expiration date every this many
        seconds. If it doesn't have enough balance, it extends as long as
        possible. If it is empty when it expires, then it is deleted.
        """
    @property
    def shardID(self) -> proto.basic_types_pb2.ShardID:
        """*
        The shard in which this account is created
        """
    @property
    def realmID(self) -> proto.basic_types_pb2.RealmID:
        """*
        The realm in which this account is created (leave this null to create a
        new realm)
        """
    @property
    def newRealmAdminKey(self) -> proto.basic_types_pb2.Key:
        """*
        If realmID is null, then this the admin key for the new realm that will be
        created
        """
    memo: builtins.str
    """*
    The memo associated with the account (UTF-8 encoding max 100 bytes)
    """
    max_automatic_token_associations: builtins.int
    """*
    The maximum number of tokens that an Account can be implicitly associated
    with. Defaults to 0 and up to a maximum value of 1000.
    """
    @property
    def staked_account_id(self) -> proto.basic_types_pb2.AccountID:
        """*
        ID of the account to which this account is staking.
        """
    staked_node_id: builtins.int
    """*
    ID of the node this account is staked to.
    """
    decline_reward: builtins.bool
    """*
    If true, the account declines receiving a staking reward. The default
    value is false.
    """
    def __init__(
        self,
        *,
        key: proto.basic_types_pb2.Key | None = ...,
        initialBalance: builtins.int = ...,
        proxyAccountID: proto.basic_types_pb2.AccountID | None = ...,
        sendRecordThreshold: builtins.int = ...,
        receiveRecordThreshold: builtins.int = ...,
        receiverSigRequired: builtins.bool = ...,
        autoRenewPeriod: proto.duration_pb2.Duration | None = ...,
        shardID: proto.basic_types_pb2.ShardID | None = ...,
        realmID: proto.basic_types_pb2.RealmID | None = ...,
        newRealmAdminKey: proto.basic_types_pb2.Key | None = ...,
        memo: builtins.str = ...,
        max_automatic_token_associations: builtins.int = ...,
        staked_account_id: proto.basic_types_pb2.AccountID | None = ...,
        staked_node_id: builtins.int = ...,
        decline_reward: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["autoRenewPeriod", b"autoRenewPeriod", "key", b"key", "newRealmAdminKey", b"newRealmAdminKey", "proxyAccountID", b"proxyAccountID", "realmID", b"realmID", "shardID", b"shardID", "staked_account_id", b"staked_account_id", "staked_id", b"staked_id", "staked_node_id", b"staked_node_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["autoRenewPeriod", b"autoRenewPeriod", "decline_reward", b"decline_reward", "initialBalance", b"initialBalance", "key", b"key", "max_automatic_token_associations", b"max_automatic_token_associations", "memo", b"memo", "newRealmAdminKey", b"newRealmAdminKey", "proxyAccountID", b"proxyAccountID", "realmID", b"realmID", "receiveRecordThreshold", b"receiveRecordThreshold", "receiverSigRequired", b"receiverSigRequired", "sendRecordThreshold", b"sendRecordThreshold", "shardID", b"shardID", "staked_account_id", b"staked_account_id", "staked_id", b"staked_id", "staked_node_id", b"staked_node_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["staked_id", b"staked_id"]) -> typing_extensions.Literal["staked_account_id", "staked_node_id"] | None: ...

global___CryptoCreateTransactionBody = CryptoCreateTransactionBody
