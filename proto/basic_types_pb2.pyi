"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import proto.timestamp_pb2
import proto.wrappers_pb2
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ShardID(google.protobuf.message.Message):
    """*
    Each shard has a nonnegative shard number. Each realm within a given shard
    has a nonnegative realm number (that number might be reused in other
    shards). And each account, file, and smart contract instance within a given
    realm has a nonnegative number (which might be reused in other realms).
    Every account, file, and smart contract instance is within exactly one
    realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2
    within realm 1  within shard 0. Each realm maintains a single counter for
    assigning numbers,  so if there is a file with ID 0.1.2, then there won't be
    an account or smart contract instance with ID 0.1.2.

    Everything is partitioned into realms so that each Solidity smart contract
    can  access everything in just a single realm, locking all those entities
    while it's  running, but other smart contracts could potentially run in
    other realms in  parallel. So realms allow Solidity to be parallelized
    somewhat, even though the  language itself assumes everything is serial.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    the shard number (nonnegative)
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["shardNum", b"shardNum"]) -> None: ...

global___ShardID = ShardID

@typing_extensions.final
class RealmID(google.protobuf.message.Message):
    """*
    The ID for a realm. Within a given shard, every realm has a unique ID. Each
    account, file, and contract instance belongs to exactly one realm.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    REALMNUM_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    The shard number (nonnegative)
    """
    realmNum: builtins.int
    """*
    The realm number (nonnegative)
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
        realmNum: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["realmNum", b"realmNum", "shardNum", b"shardNum"]) -> None: ...

global___RealmID = RealmID

@typing_extensions.final
class AccountID(google.protobuf.message.Message):
    """*
    The ID for an a cryptocurrency account
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    REALMNUM_FIELD_NUMBER: builtins.int
    ACCOUNTNUM_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    The shard number (nonnegative)
    """
    realmNum: builtins.int
    """*
    The realm number (nonnegative)
    """
    accountNum: builtins.int
    """*
    A non-negative account number unique within its realm
    """
    alias: builtins.bytes
    """*
    The public key bytes to be used as the account's alias. The public key
    bytes are the result of serializing a protobuf Key message for any
    primitive key type. Currently only primitive key bytes are supported as
    an alias (ThresholdKey, KeyList, ContractID, and delegatable_contract_id
    are not supported)

    At most one account can ever have a given alias and it is used for
    account creation if it was automatically created using a crypto
    transfer. It will be null if an account is created normally. It is
    immutable once it is set for an account.

    If a transaction auto-creates the account, any further transfers to that
    alias will simply be deposited in that account, without creating
    anything, and with no creation fee being charged.
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
        realmNum: builtins.int = ...,
        accountNum: builtins.int = ...,
        alias: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["account", b"account", "accountNum", b"accountNum", "alias", b"alias"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["account", b"account", "accountNum", b"accountNum", "alias", b"alias", "realmNum", b"realmNum", "shardNum", b"shardNum"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["account", b"account"]) -> typing_extensions.Literal["accountNum", "alias"] | None: ...

global___AccountID = AccountID

@typing_extensions.final
class FileID(google.protobuf.message.Message):
    """*
    The ID for a file
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    REALMNUM_FIELD_NUMBER: builtins.int
    FILENUM_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    The shard number (nonnegative)
    """
    realmNum: builtins.int
    """*
    The realm number (nonnegative)
    """
    fileNum: builtins.int
    """*
    A nonnegative File number unique within its realm
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
        realmNum: builtins.int = ...,
        fileNum: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["fileNum", b"fileNum", "realmNum", b"realmNum", "shardNum", b"shardNum"]) -> None: ...

global___FileID = FileID

@typing_extensions.final
class ContractID(google.protobuf.message.Message):
    """*
    The ID for a smart contract instance
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    REALMNUM_FIELD_NUMBER: builtins.int
    CONTRACTNUM_FIELD_NUMBER: builtins.int
    EVM_ADDRESS_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    The shard number (nonnegative)
    """
    realmNum: builtins.int
    """*
    The realm number (nonnegative)
    """
    contractNum: builtins.int
    """*
    A nonnegative number unique within a given shard and realm
    """
    evm_address: builtins.bytes
    """*
    The 20-byte EVM address of the contract to call.

    Every contract has an EVM address determined by its
    <tt>shard.realm.num</tt> id. This address is as follows: <ol> <li>The
    first 4 bytes are the big-endian representation of the shard.</li>
        <li>The next 8 bytes are the big-endian representation of the
    realm.</li> <li>The final 8 bytes are the big-endian representation of
    the number.</li>
      </ol>

    Contracts created via CREATE2 have an <b>additional, primary address</b>
    that is derived from the <a
    href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
    specification, and does not have a simple relation to a
    <tt>shard.realm.num</tt> id.

    (Please do note that CREATE2 contracts can also be referenced by the
    three-part EVM address described above.)
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
        realmNum: builtins.int = ...,
        contractNum: builtins.int = ...,
        evm_address: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["contract", b"contract", "contractNum", b"contractNum", "evm_address", b"evm_address"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["contract", b"contract", "contractNum", b"contractNum", "evm_address", b"evm_address", "realmNum", b"realmNum", "shardNum", b"shardNum"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["contract", b"contract"]) -> typing_extensions.Literal["contractNum", "evm_address"] | None: ...

global___ContractID = ContractID

@typing_extensions.final
class TransactionID(google.protobuf.message.Message):
    """*
    The ID for a transaction. This is used for retrieving receipts and records
    for a transaction, for appending to a file right after creating it, for
    instantiating a smart contract with bytecode in a file just created, and
    internally by the network for detecting when duplicate transactions are
    submitted. A user might get a transaction processed faster by submitting it
    to N nodes, each with a different node account, but all with the same
    TransactionID. Then, the transaction will take effect when the first of all
    those nodes submits the transaction and it reaches consensus. The other
    transactions will not take effect. So this could make the transaction take
    effect faster, if any given node might be slow. However, the full
    transaction fee is charged for each transaction, so the total fee is N times
    as much if the transaction is sent to N nodes.

    Applicable to Scheduled Transactions:
     - The ID of a Scheduled Transaction has transactionValidStart and
    accountIDs inherited from the ScheduleCreate transaction that created it.
    That is to say that they are equal
     - The scheduled property is true for Scheduled Transactions
     - transactionValidStart, accountID and scheduled properties should be
    omitted
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRANSACTIONVALIDSTART_FIELD_NUMBER: builtins.int
    ACCOUNTID_FIELD_NUMBER: builtins.int
    SCHEDULED_FIELD_NUMBER: builtins.int
    NONCE_FIELD_NUMBER: builtins.int
    @property
    def transactionValidStart(self) -> proto.timestamp_pb2.Timestamp:
        """*
        The transaction is invalid if consensusTimestamp <
        transactionID.transactionStartValid
        """
    @property
    def accountID(self) -> global___AccountID:
        """*
        The Account ID that paid for this transaction
        """
    scheduled: builtins.bool
    """*
    Whether the Transaction is of type Scheduled or no
    """
    nonce: builtins.int
    """*
    The identifier for an internal transaction that was spawned as part
    of handling a user transaction. (These internal transactions share the
    transactionValidStart and accountID of the user transaction, so a
    nonce is necessary to give them a unique TransactionID.)

    An example is when a "parent" ContractCreate or ContractCall transaction
    calls one or more HTS precompiled contracts; each of the "child"
    transactions spawned for a precompile has a id with a different nonce.
    """
    def __init__(
        self,
        *,
        transactionValidStart: proto.timestamp_pb2.Timestamp | None = ...,
        accountID: global___AccountID | None = ...,
        scheduled: builtins.bool = ...,
        nonce: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accountID", b"accountID", "transactionValidStart", b"transactionValidStart"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accountID", b"accountID", "nonce", b"nonce", "scheduled", b"scheduled", "transactionValidStart", b"transactionValidStart"]) -> None: ...

global___TransactionID = TransactionID

@typing_extensions.final
class AccountAmount(google.protobuf.message.Message):
    """*
    An account, and the amount that it sends or receives during a cryptocurrency
    or token transfer.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNTID_FIELD_NUMBER: builtins.int
    AMOUNT_FIELD_NUMBER: builtins.int
    IS_APPROVAL_FIELD_NUMBER: builtins.int
    @property
    def accountID(self) -> global___AccountID:
        """*
        The Account ID that sends/receives cryptocurrency or tokens
        """
    amount: builtins.int
    """*
    The amount of tinybars (for Crypto transfers) or in the lowest
    denomination (for Token transfers) that the account sends(negative) or
    receives(positive)
    """
    is_approval: builtins.bool
    """*
    If true then the transfer is expected to be an approved allowance and the
    accountID is expected to be the owner. The default is false (omitted).
    """
    def __init__(
        self,
        *,
        accountID: global___AccountID | None = ...,
        amount: builtins.int = ...,
        is_approval: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accountID", b"accountID"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accountID", b"accountID", "amount", b"amount", "is_approval", b"is_approval"]) -> None: ...

global___AccountAmount = AccountAmount

@typing_extensions.final
class TransferList(google.protobuf.message.Message):
    """*
    A list of accounts and amounts to transfer out of each account (negative) or
    into it (positive).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACCOUNTAMOUNTS_FIELD_NUMBER: builtins.int
    @property
    def accountAmounts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AccountAmount]:
        """*
        Multiple list of AccountAmount pairs, each of which has an account and
        an amount to transfer into it (positive) or out of it (negative)
        Limited to 2 for a transfer between two accounts
        """
    def __init__(
        self,
        *,
        accountAmounts: collections.abc.Iterable[global___AccountAmount] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["accountAmounts", b"accountAmounts"]) -> None: ...

global___TransferList = TransferList

@typing_extensions.final
class NftTransfer(google.protobuf.message.Message):
    """*
    A sender account, a receiver account, and the serial number of an NFT of a
    Token with NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be
    the default AccountID instance (0.0.0) and when burning NFTs, the receiver
    will be the default AccountID instance.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SENDERACCOUNTID_FIELD_NUMBER: builtins.int
    RECEIVERACCOUNTID_FIELD_NUMBER: builtins.int
    SERIALNUMBER_FIELD_NUMBER: builtins.int
    IS_APPROVAL_FIELD_NUMBER: builtins.int
    @property
    def senderAccountID(self) -> global___AccountID:
        """*
        The accountID of the sender
        """
    @property
    def receiverAccountID(self) -> global___AccountID:
        """*
        The accountID of the receiver
        """
    serialNumber: builtins.int
    """*
    The serial number of the NFT
    """
    is_approval: builtins.bool
    """*
    If true then the transfer is expected to be an approved allowance and the
    senderAccountID is expected to be the owner. The default is false
    (omitted).
    """
    def __init__(
        self,
        *,
        senderAccountID: global___AccountID | None = ...,
        receiverAccountID: global___AccountID | None = ...,
        serialNumber: builtins.int = ...,
        is_approval: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["receiverAccountID", b"receiverAccountID", "senderAccountID", b"senderAccountID"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_approval", b"is_approval", "receiverAccountID", b"receiverAccountID", "senderAccountID", b"senderAccountID", "serialNumber", b"serialNumber"]) -> None: ...

global___NftTransfer = NftTransfer

@typing_extensions.final
class TokenTransferList(google.protobuf.message.Message):
    """*
    A list of token IDs and amounts representing the transferred out (negative)
    or into (positive) amounts, represented in the lowest denomination of the
    token
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKEN_FIELD_NUMBER: builtins.int
    TRANSFERS_FIELD_NUMBER: builtins.int
    NFTTRANSFERS_FIELD_NUMBER: builtins.int
    EXPECTED_DECIMALS_FIELD_NUMBER: builtins.int
    @property
    def token(self) -> global___TokenID:
        """*
        The ID of the token
        """
    @property
    def transfers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AccountAmount]:
        """*
        Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of
        AccountAmounts, each of which has an account and amount
        Limited to 2 for 1 allowed transfer (reciprocal subtraction of balance +
        actual transfer)
        """
    @property
    def nftTransfers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NftTransfer]:
        """*
        Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of
        NftTransfers, each of which has a sender and receiver account, including
        the serial number of the NFT
        Limited to 1 here
        """
    @property
    def expected_decimals(self) -> proto.wrappers_pb2.UInt32Value:
        """*
        If present, the number of decimals this fungible token type is expected to
        have. The transfer will fail with UNEXPECTED_TOKEN_DECIMALS if the actual
        decimals differ.
        """
    def __init__(
        self,
        *,
        token: global___TokenID | None = ...,
        transfers: collections.abc.Iterable[global___AccountAmount] | None = ...,
        nftTransfers: collections.abc.Iterable[global___NftTransfer] | None = ...,
        expected_decimals: proto.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expected_decimals", b"expected_decimals", "token", b"token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expected_decimals", b"expected_decimals", "nftTransfers", b"nftTransfers", "token", b"token", "transfers", b"transfers"]) -> None: ...

global___TokenTransferList = TokenTransferList

@typing_extensions.final
class Fraction(google.protobuf.message.Message):
    """*
    A rational number, used to set the amount of a value transfer to collect as
    a custom fee
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUMERATOR_FIELD_NUMBER: builtins.int
    DENOMINATOR_FIELD_NUMBER: builtins.int
    numerator: builtins.int
    """*
    The rational's numerator
    """
    denominator: builtins.int
    """*
    The rational's denominator; a zero value will result in
    FRACTION_DIVIDES_BY_ZERO
    """
    def __init__(
        self,
        *,
        numerator: builtins.int = ...,
        denominator: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["denominator", b"denominator", "numerator", b"numerator"]) -> None: ...

global___Fraction = Fraction

@typing_extensions.final
class TokenID(google.protobuf.message.Message):
    """*
    Unique identifier for a token
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHARDNUM_FIELD_NUMBER: builtins.int
    REALMNUM_FIELD_NUMBER: builtins.int
    TOKENNUM_FIELD_NUMBER: builtins.int
    shardNum: builtins.int
    """*
    A nonnegative shard number
    """
    realmNum: builtins.int
    """*
    A nonnegative realm number
    """
    tokenNum: builtins.int
    """*
    A nonnegative token number
    """
    def __init__(
        self,
        *,
        shardNum: builtins.int = ...,
        realmNum: builtins.int = ...,
        tokenNum: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["realmNum", b"realmNum", "shardNum", b"shardNum", "tokenNum", b"tokenNum"]) -> None: ...

global___TokenID = TokenID

@typing_extensions.final
class Key(google.protobuf.message.Message):
    """*
    A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
    signature schemes, where in the ECDSA(secp256k1) case we require the 33-byte
    compressed form of the public key. We call these public keys <b>primitive
    keys</b>.

    If an account has primitive key associated to it, then the corresponding
    private key must sign any transaction to transfer cryptocurrency out of it.

    A Key can also be the ID of a smart contract instance, which is then
    authorized to perform any precompiled contract action that requires this key
    to sign.

    Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the
    contract with that ID will actually create a cryptographic signature. It
    only means that when the contract calls a precompiled contract, the
    resulting "child transaction" will be authorized to perform any action
    controlled by the Key.

    A Key can be a "threshold key", which means a list of M keys, any N of which
    must sign in order for the threshold signature to be considered valid. The
    keys within a threshold signature may themselves be threshold signatures, to
    allow complex signature requirements.

    A Key can be a "key list" where all keys in the list must sign unless
    specified otherwise in the documentation for a specific transaction type
    (e.g.  FileDeleteTransactionBody).  Their use is dependent on context. For
    example, a Hedera file is created with a list of keys, where all of them
    must sign a transaction to create or modify the file, but only one of them
    is needed to sign a transaction to delete the file. So it's a single list
    that sometimes acts as a 1-of-M threshold key, and sometimes acts as an
    M-of-M threshold key.  A key list is always an M-of-M, unless specified
    otherwise in documentation. A key list can have nested key lists or
    threshold keys. Nested key lists are always M-of-M. A key list can have
    repeated primitive public keys, but all repeated keys are only required to
    sign once.

    A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so
    this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey
    which contains a list of primitive keys has 3 levels: ThresholdKey ->
    KeyList
    -> Key. A KeyList which contains several primitive keys has 2 levels:
    KeyList
    -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key ->
    ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.

    Each Key should not have more than 46 levels, which implies 15 levels of
    nested ThresholdKeys.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONTRACTID_FIELD_NUMBER: builtins.int
    ED25519_FIELD_NUMBER: builtins.int
    RSA_3072_FIELD_NUMBER: builtins.int
    ECDSA_384_FIELD_NUMBER: builtins.int
    ECDSA_SECP256K1_FIELD_NUMBER: builtins.int
    DELEGATABLE_CONTRACT_ID_FIELD_NUMBER: builtins.int
    @property
    def contractID(self) -> global___ContractID:
        """*
        smart contract instance that is authorized as if it had signed with a
        key
        """
    ed25519: builtins.bytes
    """*
    Ed25519 public key bytes
    """
    RSA_3072: builtins.bytes
    """*
    (NOT SUPPORTED) RSA-3072 public key bytes
    """
    ECDSA_384: builtins.bytes
    """*
    (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
    """
    ECDSA_secp256k1: builtins.bytes
    """KeyList keyList = 6;

    *
    Compressed ECDSA(secp256k1) public key bytes
    """
    @property
    def delegatable_contract_id(self) -> global___ContractID:
        """*
        A smart contract that, if the recipient of the active message frame,
        should be treated as having signed. (Note this does not mean the <i>code
        being executed in the frame</i> will belong to the given contract, since
        it could be running another contract's code via <tt>delegatecall</tt>.
        So setting this key is a more permissive version of setting the
        contractID key, which also requires the code in the active message frame
        belong to the the contract with the given id.)
        """
    def __init__(
        self,
        *,
        contractID: global___ContractID | None = ...,
        ed25519: builtins.bytes = ...,
        RSA_3072: builtins.bytes = ...,
        ECDSA_384: builtins.bytes = ...,
        ECDSA_secp256k1: builtins.bytes = ...,
        delegatable_contract_id: global___ContractID | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ECDSA_384", b"ECDSA_384", "ECDSA_secp256k1", b"ECDSA_secp256k1", "RSA_3072", b"RSA_3072", "contractID", b"contractID", "delegatable_contract_id", b"delegatable_contract_id", "ed25519", b"ed25519", "key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ECDSA_384", b"ECDSA_384", "ECDSA_secp256k1", b"ECDSA_secp256k1", "RSA_3072", b"RSA_3072", "contractID", b"contractID", "delegatable_contract_id", b"delegatable_contract_id", "ed25519", b"ed25519", "key", b"key"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["key", b"key"]) -> typing_extensions.Literal["contractID", "ed25519", "RSA_3072", "ECDSA_384", "ECDSA_secp256k1", "delegatable_contract_id"] | None: ...

global___Key = Key

@typing_extensions.final
class ThresholdKey(google.protobuf.message.Message):
    """*
    A set of public keys that are used together to form a threshold signature.
    If the threshold is N and there are M keys, then this is an N of M threshold
    signature. If an account is associated with ThresholdKeys, then a
    transaction to move cryptocurrency out of it must be signed by a list of M
    signatures, where at most M-N of them are blank, and the other at least N of
    them are valid signatures corresponding to at least N of the public keys
    listed here.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    THRESHOLD_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    threshold: builtins.int
    """*
    A valid signature set must have at least this many signatures
    """
    @property
    def keys(self) -> global___KeyList:
        """*
        List of all the keys that can sign
        """
    def __init__(
        self,
        *,
        threshold: builtins.int = ...,
        keys: global___KeyList | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["keys", b"keys"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys", b"keys", "threshold", b"threshold"]) -> None: ...

global___ThresholdKey = ThresholdKey

@typing_extensions.final
class KeyList(google.protobuf.message.Message):
    """*
    A list of keys that requires all keys (M-of-M) to sign unless otherwise
    specified in documentation. A KeyList may contain repeated keys, but all
    repeated keys are only required to sign once.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Key]:
        """*
        list of keys
        Limited to 1 here (because we don't have malloc!)
        """
    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[global___Key] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["keys", b"keys"]) -> None: ...

global___KeyList = KeyList

@typing_extensions.final
class TokenBalance(google.protobuf.message.Message):
    """*
    A number of <i>transferable units</i> of a certain token.

    The transferable unit of a token is its smallest denomination, as given by
    the token's <tt>decimals</tt> property---each minted token contains
    <tt>10<sup>decimals</sup></tt> transferable units. For example, we could
    think of the cent as the transferable unit of the US dollar
    (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
    (<tt>decimals=8</tt>).

    Transferable units are not directly comparable across different tokens.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKENID_FIELD_NUMBER: builtins.int
    BALANCE_FIELD_NUMBER: builtins.int
    DECIMALS_FIELD_NUMBER: builtins.int
    @property
    def tokenId(self) -> global___TokenID:
        """*
        A unique token id
        """
    balance: builtins.int
    """*
    Number of transferable units of the identified token. For token of type
    FUNGIBLE_COMMON - balance in the smallest denomination. For token of type
    NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
    """
    decimals: builtins.int
    """*
    Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
    """
    def __init__(
        self,
        *,
        tokenId: global___TokenID | None = ...,
        balance: builtins.int = ...,
        decimals: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["tokenId", b"tokenId"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["balance", b"balance", "decimals", b"decimals", "tokenId", b"tokenId"]) -> None: ...

global___TokenBalance = TokenBalance

@typing_extensions.final
class TokenBalances(google.protobuf.message.Message):
    """*
    A sequence of token balances
    Limited to 1 here
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKENBALANCES_FIELD_NUMBER: builtins.int
    @property
    def tokenBalances(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TokenBalance]: ...
    def __init__(
        self,
        *,
        tokenBalances: collections.abc.Iterable[global___TokenBalance] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["tokenBalances", b"tokenBalances"]) -> None: ...

global___TokenBalances = TokenBalances

@typing_extensions.final
class TokenAssociation(google.protobuf.message.Message):
    """A token - account association"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKEN_ID_FIELD_NUMBER: builtins.int
    ACCOUNT_ID_FIELD_NUMBER: builtins.int
    @property
    def token_id(self) -> global___TokenID:
        """The token involved in the association"""
    @property
    def account_id(self) -> global___AccountID:
        """The account involved in the association"""
    def __init__(
        self,
        *,
        token_id: global___TokenID | None = ...,
        account_id: global___AccountID | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["account_id", b"account_id", "token_id", b"token_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["account_id", b"account_id", "token_id", b"token_id"]) -> None: ...

global___TokenAssociation = TokenAssociation

@typing_extensions.final
class StakingInfo(google.protobuf.message.Message):
    """*
    Staking metadata for an account or a contract returned in CryptoGetInfo or
    ContractGetInfo queries
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DECLINE_REWARD_FIELD_NUMBER: builtins.int
    STAKE_PERIOD_START_FIELD_NUMBER: builtins.int
    PENDING_REWARD_FIELD_NUMBER: builtins.int
    STAKED_TO_ME_FIELD_NUMBER: builtins.int
    STAKED_ACCOUNT_ID_FIELD_NUMBER: builtins.int
    STAKED_NODE_ID_FIELD_NUMBER: builtins.int
    decline_reward: builtins.bool
    """*
    If true, this account or contract declined to receive a staking reward.
    """
    @property
    def stake_period_start(self) -> proto.timestamp_pb2.Timestamp:
        """*
        The staking period during which either the staking settings for this
        account or contract changed (such as starting staking or changing
        staked_node_id) or the most recent reward was earned, whichever is later.
        If this account or contract is not currently staked to a node, then this
        field is not set.
        """
    pending_reward: builtins.int
    """*
    The amount in tinybars that will be received in the next reward situation.
    """
    staked_to_me: builtins.int
    """*
    The total of balance of all accounts staked to this account or contract.
    """
    @property
    def staked_account_id(self) -> global___AccountID:
        """*
        The account to which this account or contract is staking.
        """
    staked_node_id: builtins.int
    """*
    The ID of the node this account or contract is staked to.
    """
    def __init__(
        self,
        *,
        decline_reward: builtins.bool = ...,
        stake_period_start: proto.timestamp_pb2.Timestamp | None = ...,
        pending_reward: builtins.int = ...,
        staked_to_me: builtins.int = ...,
        staked_account_id: global___AccountID | None = ...,
        staked_node_id: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["stake_period_start", b"stake_period_start", "staked_account_id", b"staked_account_id", "staked_id", b"staked_id", "staked_node_id", b"staked_node_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["decline_reward", b"decline_reward", "pending_reward", b"pending_reward", "stake_period_start", b"stake_period_start", "staked_account_id", b"staked_account_id", "staked_id", b"staked_id", "staked_node_id", b"staked_node_id", "staked_to_me", b"staked_to_me"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["staked_id", b"staked_id"]) -> typing_extensions.Literal["staked_account_id", "staked_node_id"] | None: ...

global___StakingInfo = StakingInfo
